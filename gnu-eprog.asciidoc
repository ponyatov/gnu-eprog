Программирование встраиваемых систем с использованием GNU Toolchain
===================================================================
:Author:          Vijay Kumar B.
:Email:           vijaykumar@bravegnu.org
:Author Initials: BVK
:Revision:	  0.6.0
:Key words:	  gnu, gcc, compiler, linker, lds, embedded, microcontroller, arm
:Revision history:

[[intro]]
Введение
--------

Пакет компиляторов GNU toolchain широко используется при разработке 
программного обеспечения для встраиваемых систем. Этот тип разработки ПО также 
называют `низкоуровневым`, `standalone` или `bare metal` программированием
(на Си и C++).
Написание низкоуровневого кода на Си добавляет программисту новых проблем,
требующих глубокого понимания инструмента разработчика -- GNU Toolchain.
Руководства разработчика GNU Toolchain предоставляют отличную информацию по
инструментарию, но с точки зрения самого GNU Toolchain, чем с точки зрения 
решаемой проблемы. Поэтому было написано это руководство, в котором будут
описаны типичные проблемы, с которыми сталкивается начинающий разработчик.

Этот учебник стремится занять свое место, объясняя использование GNU toolchain с точки
зрения практического использования. Надеемся, что его будет достаточно для
разработчиков, собирающихся освоить и использовать GNU toolchain в их embedded
проектах.

В иллюстративных целях была выбрана встроенная система на базе процессорного
ядра ARM, которая эмулируется в пакете Qemu. С таким подходом вы сможете
освоить GNU toolchain с комфортом на вашем рабочем компьютере, без необходимости
вкладываться в "физическое" железо, и бороться со сложностями с его запуском.
Учебник не стремиться обучить работе с архитектурой ARM, для этого вам нужно
будет воспользоваться дополнительными книгами или онлайн-учебниками типа:

  * ARM Assembler - http://www.heyrick.co.uk/assembler/
  * ARM Assembly Language Programming - http://www.arm.com/miscPDFs/9658.pdf

Но для удобства читателя, некоторое множество часто используемых ARM-инструкций
описано в приложении.

[[arm-lab]]
Настройка тестового стенда
--------------------------

В этом разделе описано, как настроить на вашей рабочей станции простую среду
разработки и тестирования ПО для платформы ARM, используя Qemu и GNU toolchain.
Qemu это программный (для i386 -- программно-аппаратный, использует
средства виртуализации хост-компьютера) эмулятор нескольких распространенных
аппаратных платформ. Вы можете написать программу на ассемблере и Си,
скомпилировать ее используя GNU toolchain и отладить ее в эмуляторе Qemu.

Qemu ARM
~~~~~~~~

Будем использовать Qemu для эмуляции отладочной платы `Gumstix connex` на базе
процессора PXA255. Для работы с этим учебником у вас должен быть установлен
Qemu версии не ниже 0.9.1.

Процессор (точнее SoC: система-на-кристалле) PXA255 имеет ядро ARM c
набором инструкций ARMv5TE. PXA255 также имеет в своем составе несколько блоков
периферии. Некоторая периферия будет описана в этом курсе далее.

Инсталляция Qemu на Debian
~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Этот учебник требует Qemu версии не ниже 0.9.1. Пакет Qemu доступный для
современных дистрибутивов Debian, вполне удовлетворяет этим условиям, и
собирать свежий Qemu из исходников совсем не требуется (хотя может быть и
очень хочется). Установим пакет командой:

------
$ apt-get install qemu
------

Установка кросс-компилятора GNU Toolchain для ARM
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Если вы предпочитаете простые пути, установите пакет кросс-компилятора командной

------
sudo apt install gcc-arm-none-eabi
------

или

  1. Годные чуваки из CodeSourcery (подразделение Mentor Graphics)
уже давно запилили несколько вариантов GNU Toolchainов для разных ходовых
  архитектур. Скачайте готовую бинарную бесплатную lite-сборку
     http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/
+
  2. Распакуйте tar-архив в каталог `~/toolchains`.
+
------
$ mkdir ~/toolchains
$ cd ~/toolchains
$ tar -jxf ~/downloads/arm-2008q1-126-arm-none-eabi-i686-pc-linux-gnu.tar.bz2 
------
+
  3. Добавьте bin-каталог тулчейна в переменную среды `PATH`.
+
------
$ PATH=$HOME/toolchains/arm-2008q1/bin:$PATH
------
+
  4. Чтобы каждый раз не выполнять предыдущую команду, вы можете прописать
ее в дот-файл `.bashrc`.

[[hello-arm]]
Hello ARM
---------

В этом разделе вы научитесь пользоваться arm-ассемблером, и тестировать вашу
программу на голом железе -- эмуляторе платы `connex` в Qemu.

Файл исходника ассемблерной программы состоит из последовательности инструкций,
по одной на каждую строку. Каждая инструкция имеет формат:

------
<метка>:    <инструкция>         @ <комментарий>
------

Каждый компонент не обязателен. 

`метка`::
Метка -- типичный способ пометить адрес инструкции в памяти. Метка
может быть использована там, где требуется указать адрес, например как операнд
в команде перехода. Метка может состоять из латинских букв, цифр (цифра не может
быть первым символом метки), символов `_` и `$`.

`комментарий`::
Комментарий начинается с символа `@` -- все последующие символы
игнориуются до конца строки.

`инструкция`::
Инструкция может быть инструкцией процессора или директивой ассемблера,
начинающейся с точки "`.`"

Вот пример простой ассемблерной программы для процессора ARM, складывающей
два числа:

[[add]]
.Сложение двух чисел
[lang="armasm"]
------
	.text                
start:                    @ метка необязательна
	mov   r0, #5      @ загрузить в регистр r0 значение 5
	mov   r1, #4      @ загрузить в регистр r1 значение 4
	add   r2, r1, r0  @ сложить r0+r1 и сохранить в r2
	                  @ (справа налево)
	
stop:	b stop            @ пустой бесконечный цикл
                          @ для останова выполнения
------

`.text` ассемблерная директива, указывающая что последующий код должен
быть ассемблирован в секцию кода .text, а не в секцию
`.data`. Секции будут подробно описаны далее.

Сборка бинарника
~~~~~~~~~~~~~~~~

Сохраните программу в файл `add.s` ( `.s` или `.S` стандарное расширение в
мире OpenSource, указывает что это файл с программной на ассемблере).
Для ассемблирования файла вызовите ассемблер `as`:

------
$ arm-none-eabi-as -o add.o add.s
------

Опция `-o` указывает выходной файл с `объектным кодом`, имеющий стандартное 
расширение `.o` (и внутренний формат ELF (как завещал великий Linux)).

NOTE: Команды кросс-тулчейна всегда имеют префикс целевой архитектуры
(target triplet), для которой они были собраны, чтобы предотвратить
конфликт имен с хост-тулчейном для вашего рабочего компьютера. Далее утилиты
GNU Toolchain будут использоваться без префикса для лучшей читаемости. Не
забывайте добавлять `arm-none-eabi-`, иначе получите множество странных
ошибок типа "unexpected command".

------
$ (arm-none-eabi-)as -o add.o add.s
$ (arm-none-eabi-)objdump -x add.o
------

.вывод команды `arm-none-eabi-objdump -x`: ELF-заголовки в файле объектного кода
------
add.o:     file format elf32-littlearm
add.o
architecture: armv4, flags 0x00000010:
HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000010  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000044  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000044  2**0
                  ALLOC
  3 .ARM.attributes 00000014  00000000  00000000  00000044  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l       .text	00000000 start
0000000c l       .text	00000000 stop
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
------

Секция `.text` имеет размер `Size=0x0010` =16 байт, и содержит
`машинный код`:

.машинный код из секции .text: `objdump -d`
------
add.o:     file format elf32-littlearm

Disassembly of section .text:

00000000 <start>:
   0:	e3a00005 	mov	r0, #5
   4:	e3a01004 	mov	r1, #4
   8:	e0812000 	add	r2, r1, r0

0000000c <stop>:
   c:	eafffffe 	b	c <stop>
------

Для генерации `исполняемого файла` (обычно тот же формат ELF.o,
слепленный из одного или нескольких объектных файлов, с некоторыми
модификациями см. опцию -T далее) вызовем линкер `ld`:

------
$ arm-none-eabi-ld -Ttext=0x0 -o add.elf add.o
------

Опять, опция `-o` задает выходной файл. `-Ttext=0x0` явно указывает
адрес, от которого будут отсчитываться все метки, т.е. секция инструкций
начинается с адреса `0x0000`. Для просмотра адресов, назначенных меткам,
можно использовать команду `(arm-none-eabi-)nm` (NaMes):

------
$ arm-none-eabi-nm add.elf
... clip ...
00000000 t start
0000000c t stop
------

Обратите внимание на назначение адресов для меток
`start` и `stop`: адреса начанаются с `0x0`. Это адрес первой инструкции.
`stop` находится после третьей инструкции. Каждая инструкция занимает
4 байта (*), так что `stop` находится по адресу `0xC`.

* в множестве команд ARM-32, если вы компилируете код для
микроконтроллера Cortex-M в режиме команд Thumb или Thumb2, команды 16-битные, т.е.
2 байта

Линковка с другим базовым адресом `-Ttext=nnnn` приведет к сдвигу адресов, 
назначенных меткам.

------
$ arm-none-eabi-ld -Ttext=0x20000000 -o add.elf add.o
$ arm-none-eabi-nm add.elf
... clip ...
20000000 t start
2000000c t stop
------

Выходной файл, созданный `ld` имеет формат, который называется
`ELF`. Существует множество форматов, предназначенных для хранения
выполняемого и объектного кода (можно отдельно отметить Microsoft COFF
(объектные файлы .obj) и PE (.exe)cutable ). Формат ELF применяется для хранения
машинного кода, если вы запускаете его в базовой ОС (прежде всего
"большой" или встраиваемый Linux), но поскольку мы собираемся запускать нашу
программу на bare metal (голом железе), мы должны сконвертировать полученный
.elf файл в более простой `бинарный формат`.

Файл в `бинарном` формате содержит последовательность байт, начинающуюся с
определенного адреса памяти, поэтому бинарный файл еще называют `образом памяти`. Этот
формат типичен для утилит программирования флеш-памяти микроконтроллеров, так
как все что требуется сделать -- последовательно скопировать каждый байт из
файла в FlashROM-память микроконтроллера, начиная с определенного начального
адреса. Та же операция выполняется и для SoC-систем с NAND-флешем:
записать бинарный образ начиная с некоторого аппаратно фиксированного адреса.

Команда GNU toolchain `objcopy` используется для конвертирования машинного кода
между разными объектными форматами. Типичное использование:

------
objcopy -O <output-format> <in-file> <out-file>
------

Конвертируем `add.elf` в бинарный формат:

------
$ arm-none-eabi-objcopy -O binary add.elf add.bin
------

Проверим размер полученного бинарного файла, он должен быть равен тем же 16
байтам: 4 инструкции по 4 байта каждая}:

------
$ ls -al add.bin
-rw-r--r-- 1 vijaykumar vijaykumar 16 2008-10-03 23:56 add.bin
------

Если вы не доверяете ls, можно `дизассемблировать бинарный файл`:

------
$ arm-none-eabi-objdump -b binary -m arm -D add.bin

add.bin:     file format binary

Disassembly of section .data:

00000000 <.data>:
   0:   e3a00005        mov     r0, #5
   4:   e3a01004        mov     r1, #4
   8:   e0812000        add     r2, r1, r0
   c:   eafffffe        b       0xc
ponyatov@bs:/tmp$ 
------

Опция `-b` задает формат файла, опция `-m` (machine) архитектуру
процессора, получить полный список сочетаний -b/-m можно командной
`arm-none-eabi-objdump -i`.

Выполнение в Qemu
~~~~~~~~~~~~~~~~~

Когда ARM-процессор сбрасывается, он начинает выполнять команды с адреса `0x0`.
На плате connex установлен флеш на 16 мегабайт, начинающийся с адреса `0x0`. Таким
образом, при сбросе будут выполняться инструкции с начала флеша.

Когда `qemu` эмулирует плату connex, в командной строке должен быть указан
файл,
который будет считаться образом флеш-памяти. Формат флеша очень прост -- это
побайтный образ флеша без каких-либо полей или заголовков, т.е. это тот же самый
`бинарный формат`, описанный выше.

Для тестирования программы в эмуляторе Gumstix connex, сначала мы создаем
16-мегабайтный файл флеша, копируя 16М нулей из файла `/dev/zero` с
помощью команды `dd`. Данные копируются 4Кбайтными блоками (опция `bs=
(blocksize)`: 4096 х 4К :

------
$ dd if=/dev/zero of=flash.bin bs=4K count=4096
4096+0 записей получено
4096+0 записей отправлено
 скопировано 16777216 байт (17 MB), 0,0153502 c, 1,1 GB/c

$ du -h flash.bin 
16M     flash.bin
------

Затем переписываем начало `flash.bin` копируя в него содержимое
`add.bin`:

------
$ dd if=add.bin of=flash.bin bs=4K conv=notrunc
0+1 записей получено
0+1 записей отправлено
 скопировано 16 байт (16 B), 0,000173038 c, 92,5 kB/c
------

После сброса процессор выполняет код с адреса `0x0`, и будут выполняться
инструкции нашей программы. Команда запуска `qemu`:

------
$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null

QEMU 2.1.2 monitor - type 'help' for more information
(qemu) 
------

Опция `-M connex` выбирает режим эмуляции: Qemu поддерживает эмуляцию
нескольких десятков вариантов железа на базе ARM процессоров. Опция `-pflash`
указывает файл образа флеша, который должен иметь определенный размер (16М).
`-nographic` отключает эмуляцию графического дисплея (в отдельном окне).
Самая важная опция `-serial /dev/null` подключает последовательный порт
платы на `/dev/null`, при этом в терминале после запуска Qemu вы получите
`консоль монитора`.

Qemu выполняет инструкции, и останавливается в бесконечном цикле на
`stop`, выполняя команду `stop: b stop`. Для просмотра содержимого
регистров процессора воспользуемся`монитором` Qemu.
Монитор имеет интерфейс командной строки, который вы можете использовать для
контроля работы эмулируемой системы. Если вы запустите `qemu` как указано выше,
монитор будет доступен через stdio.

Для просмотра регистров выполним команду `info registers`:

------
(qemu) info registers
R00=00000005 R01=00000004 R02=00000009 R03=00000000
R04=00000000 R05=00000000 R06=00000000 R07=00000000
R08=00000000 R09=00000000 R10=00000000 R11=00000000
R12=00000000 R13=00000000 R14=00000000 R15=0000000c
PSR=400001d3 -Z-- A svc32
------

Обратите внимание на значения в регистрах `r00`..`r02`: 4, 5 и ожидаемый результат
9. Особое значение для ARM имеет регистр `r15`: он является указателем команд, и
содержит адрес текущей выполняемой машинной команды, т.е. `0x000c: b stop`.

Другие команды монитора
~~~~~~~~~~~~~~~~~~~~~~~

Несколько полезных команд монитора:

[options="header"]
|======
| Команда         | Назначение
| `help`	  | список доступных команд
| `quit`	  | выход из эмулятора
| `xp /fmt addr`  | вывод содержимого физической памяти с адреса `addr`
| `system_reset`  | перезапуск
|======

Команда `xp` требует некоторых пояснений. Аргумент `/fmt` указывает
как будет выводиться содержимое памяти, и имеет синтаксис
`<счетчик><формат><размер>`:

`счетчик`::
число элементов данных

`размер`::
размер одного элемента в битах: `b=8` бит, `h=16`, `w=32`, `g=64`

`формат`::
определяет формат вывода: `x` hex, `d` десятичные целые со знаком, `u`
десятичные без знака, `o` 8ричные, `c` символ (char) и `i`
инструкции ассемблера.

Команда `xp` в формате `i` будет дизассемблировать инструкции из
памяти. Выведем дамп с адреса `0x0` указав `fmt=4iw`: 4 -- четыре , i --
инструкции размером `w` -- 32 бита:

------
(qemu) xp /4iw 0x0
0x00000000:  mov        r0, #5  ; 0x5
0x00000004:  mov        r1, #4  ; 0x4
0x00000008:  add        r2, r1, r0
0x0000000c:  b  0xc
------

[[asm-directives]]
Директивы ассемблера
--------------------

В этом разделе мы посмотрим несколько часто используемых директив ассемблера,
используя в качестве примера пару простых программ.

Суммирование массива
~~~~~~~~~~~~~~~~~~~~

Следующий код вычисляет сумму массива байт и сохраняет результат в `r3`:

.Сумма массива
[lang="armasm"]
------
include::code/sum.s[]
------

В коде используются две новых ассемблерных директивы, описанных далее:
`.byte` и `.align`.

Директива `.byte`
^^^^^^^^^^^^^^^^^

Аргументы директивы `.byte` ассемблируются в последовательность байт в
памяти. Также существуют аналогичные директивы `.2byte` и `.4byte`
для ассемблирования 16- и 32-битных констант:

------
.byte   exp1, exp2, ...
.2byte  exp1, exp2, ...
.4byte  exp1, exp2, ...
------

Аргументом может быть целый числовой литерал: двоичный с префиксом `0b`, 8-ричный
префикс `0`, десятичный и hex `0x`. Также может использоваться строковая константа в
одиночных кавычках, ассемблируемая в ASCII значения.

Также аргументом может быть Си-выражение из литералов и других символов,
примеры:

------
pattern:  .byte 0b01010101, 0b00110011, 0b00001111
npattern: .byte npattern - pattern
halpha:   .byte 'A', 'B', 'C', 'D', 'E', 'F'
dummy:    .4byte 0xDEADBEEF
nalpha:   .byte 'Z' - 'A' + 1
------

Директива `.align`
^^^^^^^^^^^^^^^^^^

Архитектура ARM требует чтобы инструкции находились в адресах памяти,
выровненных по границам 32-битного слова, т.е. в адресах с нулями в 2х младших
разрядах. Другими словами, адрес каждого первого байта из 4-байтной команды,
должен быть кратен 4. Для обеспечения этого предназначена директива
`.align`, которая вставляет выравнивающие байты до следующего `выровненного
адреса`. Ее нужно использовать только если в код вставляются байты или неполные
32-битные слова.

Вычисление длины строки
~~~~~~~~~~~~~~~~~~~~~~~

Этот код вычисляет длину строки и помещает ее в `r1`:

.Длина строки
[lang="armasm"]
------
        .text
        b start

str:    .asciz "Hello World"

        .equ   nul, 0

        .align
start:  ldr   r0, =str          @ r0 = &str
        mov   r1, #0

loop:   ldrb  r2, [r0], #1      @ r2 = *(r0++)
        add   r1, r1, #1        @ r1 += 1
        cmp   r2, #nul          @ if (r1 != nul)
        bne   loop              @ goto loop

        sub   r1, r1, #1        @ r1 -= 1
stop:   b stop
------

Код иллюстрирует применение директив `.asciz` и `.equ`.

Директива `.asciz`
^^^^^^^^^^^^^^^^^^
Директива `.asciz` принимает аргумент: строковый литерал,
последовательность символов в двойных кавычках. Строковые литералы
ассемблируются в память последовательно, добавляя в конец нулевой символ
`\0` (признак конца строки в языке Си и стандарте POSIX).

Директива `.ascii` аналогична `.asciz`, но конец строки не
добавляется. Все символы -- 8-битные, кириллица может не поддерживаться.

Директива `.equ`
^^^^^^^^^^^^^^^^

Ассемблер при свой работе использует `таблицу символов`: она хранит 
соответствия меток и их адресов. Когда ассемблер встречает
очередное определение метки, он добавляет в таблицу новую запись. Когда
встречается упоминание метки, оно заменяется соответствующим адресом из
таблицы.

Использование директивы `.equ` позволяет добавлять записи в
таблицу символов вручную, для привязки к именам любых числовых значений, не
обязательно адресов. Когда ассемблер встречает эти имена, они заменяются на их
значения. Эти имена-константы, и имена меток, называются
`сиволами`, а таблицы записанные в объектные файлы, или в
отдельные `.sym` файлы -- `таблицами символов` (*)

* также используются отладчиком, чтобы показывать адреса переходов
в виде понятных программисту сиволов, а не мутных числовых констант

Синтаксис директивы .equ:

------
.equ <имя>, <выражение>
------

`Имя` символа имеет те же ограничения по используемым символам, что и метка.
`Выражение` может быть одиночным литералом или выражением как и в директиве
`.byte`.

NOTE: В отличие от `.byte`, директива `.equ` не выделяет никакой памяти под аргумент.
Она только добавляет значение в таблицу символов.  

[[using-ram]]
Использование ОЗУ (адресного пространства процессора)
-----------------------------------------------------

Flash-память описанная ранее, в которой хранится машинный код программы, один из
видов EEPROM (Electrical Eraseable Programmable Read-Only Memory,
электрически стираемая перепрограммируемая память только-для-чтения).
Это вторичный носитель данных, как например жесткий диск, но в
любом случае хранить данные и значения переменных во флеше неудобно как с точки
зрения возможности перезаписи, так и прежде всего со скоростью чтения флеша, и
кешированием.

В предыдущем примере мы использовали флеш как EEPROM для хранения константного
массива байт, но вообще переменные должны храниться в максимально быстрой и
неограниченно перезаписываемой RAM.

Плата connex имеет 64Mb ОЗУ начиная с адреса `0xA0000000`, для хранения
данных программы. Карта памяти может быть представлена в виде диаграммы:

.Карта памяти Gumstix connex
image::flash-ram-mm.png[Memory Map]
* здесь адреса считаются сверху вниз, что нетипично, обычно на диаграммах
памяти адреса увеличиваются снизу вверх.

Для настройки размещения переменных по нужным физическим адресам `нужна`
некоторая `настройка адресного пространства`, особенно `если вы
используете внешнюю память и переферийные устройства, подключемые к внешней
шине` (или используете малораспространенные клоны ARM-процессоров, типа
Миландровского 1986ВЕ9х "чернобыль").

[[linker]]
Линкер
------

Линкер позволяет `скомпоновать` исполняемый файл программы
из нескольких объектных файлов, поделив ее на части. Чаще всего это нужно при
использовании нескольких компиляторов для разных языков программирования:
ассемблер, компиляторы Си, C++, Фортрана и Паскакаля. 

Например, очень известная библиотека численных вычислений на базе матриц
BLAS/LAPACK написана на Фортране, и для ее использования с сишной программой
нужно слинковать program.o, blas.a и lapack.a (*) в один исполняемый файл.

* `.a` -- файлы архивов из пары
сотен отдельных .o файлов каждый, по одному .o файлу на каждый возможный вариант
функции линейной алгебры

При написании многофайловой программы (еще это называют `инкрементной
компоновкой`) каждый файл исходного кода ассемблируется
в индивидуальный файл объектного кода. Линкер (a.k.a компоновщик) собирает
объектные файлы в финальный исполняемый бинарник.

.Роль линкера
image::linker.png[Роль линкера]

При сборке объектных файлов, линкер выполняет следующие операции:

  1. symbol resolution (разрешение символов)
  2. relocation (релокация)

В этой секции мы детально рассмотрим эти операции.

Разрешение символов
~~~~~~~~~~~~~~~~~~~

В программе из одного файла при создании объектного файла все ссылки на метки
заменяются их адресами непосредственно ассемблером. Но в программе из нескольких
файлов существует множество ссылок на метки в других файлах, неизвестные на
момент ассемблирования/компиляции, и ассемблер помечает их `unresolved`
(неразрешЕнные). Когда эти объектные файлы обрабатываются линкером, он
определяет адреса этих меток по информации из других объектных файлов, и
корректирует код. Этот процесс называется `разрешЕние символов`.

Пример суммирования массива разделен на два файла для демонстрации разрешения
символов, выполняемых линкером. Эти файлы ассемблируются отдельно, чтобы их
таблицы символов содержали неразрешенные ссылки.

Файл `sum-sub.s` содержит процедуру суммирования, а `main.s`
вызывает процедуру с требуемыми аргументами:

[[l1]]
.`main.s` - вызов процедуры
[lang="armasm"]
------
include::code/main.s[вызов процедуры]
------

[[l2]]
.`sum-sub.s` - определение процедуры
[lang="armasm"]
------
include::code/sum-sub.s[определение процедуры]
------

Применение директивы `.global` обязательно. В Си все функции и переменные, 
определенные вне функций, считаются видимыми из других объектных файлов, если
они не определены с модификатором `static`. В ассемблере наоборот
все метки считаются
`статитическими` (или локальными на уровне файла), если с помощью директивы 
`.global` специально не указано, что они должны быть видимы извне.

Ассемблируйте файлы, и посмотрите дамп их таблицы символов используя 
комунду `nm`:

------
$ arm-none-eabi-as -o main.o main.s
$ arm-none-eabi-as -o sum-sub.o sum-sub.s
$ arm-none-eabi-nm main.o
00000004 t arr
00000007 t eoa
00000008 t start
00000018 t stop
         U sum 
$ arm-none-eabi-nm sum-sub.o
00000004 t loop
00000000 T sum
------

Теперь сфокусируемся на букву во втором столюце, который указывает тип символа:
't' указывает что символ определен в секции кода .text, 'u' указывает что символ
не определен. Буква в верхнем регистре указывает что символ глобальный и был 
указан в директиве `.global`.

Очевидно, что символ `sum` определ в `sum-sub.o` и еще не рарзрешен в
`main.o`. Вызов линкера разрешает символьные ссылки, и создает исполняемый
файл.

Релокация
~~~~~~~~~

`Релокация` -- процесс изменения уже назначенных меткам адресов. Он также
выполняет коррекцию всех ссылок, чтобы отразить заново назначенные
адреса меток. В общем, релокация выполняется по двум основным причинам:

  1. Объединение секций
  2. Размещение секций

Для понимания процеса релокации, нужно понимание самой концепции секций.

Код и данные отличаются по требованиям при исполнении. Например код может
размещаться в ROM-памяти, а данные требуют память открытую на запись. Очень
хорошо, если области кода и данных `не пересекаются`. Для этого программы 
делятся на секции. Большиство программ имеют как минимум две секции: `.text`
для кода и `.data` для данных. Ассемблерные директивы `.text` и `.data` ожидаемо
используются для переключения между этими секциями.

Хорошо представить каждую секцию как ведро. Когда ассемблер натыкается на 
директиву секции, он начинает сливать код/данные в соответствующее ведро, так 
что они размещаются в смежных адресах. Эта диаграмма показывает как ассемблер
упорядочивает данные в секциях:

.Секции
image::sections.png[Секции]

Теперь, когда у нас есть общее понимаение `секционирования` кода и данных,
давайте посмотрим по каким причинам выполняется релокация.

Объединение секций
^^^^^^^^^^^^^^^^^^

Когда вы имеете дело с многофайловыми программами, секции в каждом объектном 
файле имеют одинаковые имена (`.text`,..). Линкер отвечает за их объединение 
в выполняемом файле. По умолчанию, секции с одинаковыми именами из каждого .o
файла объединяются последовательно, и метки корректируются на новые адреса.

Эффекты объединения секций можно посмотреть, анализируя таблицы символов
отдельно в объектных и исполняемом файлах. Многофайловая программа суммирования
может иллюстрировать объединение секций. Дампы таблиц символов:

------
$ arm-none-eabi-nm main.o
00000004 t arr
00000007 t eoa
00000008 t start
00000018 t stop
         U sum 
$ arm-none-eabi-nm sum-sub.o
00000004 t loop <1>
00000000 T sum
$ arm-none-eabi-ld -Ttext=0x0 -o sum.elf main.o sum-sub.o
$ arm-none-eabi-nm sum.elf
...
00000004 t arr
00000007 t eoa
00000008 t start
00000018 t stop
00000028 t loop <1>
00000024 T sum
------

<1> символ `loop` имеет адрес `0x4` в `sum-sub.o`, и `0x28` в `sum.elf`, так как
секция `.text` из `sum-sub.o` размещена сразу за секцией `.text` из `main.o`.

Размещение секций
^^^^^^^^^^^^^^^^^

Когда программа ассемблируется, каждой секции назначается стартовый адрес `0x0`.
Поэтому всем переменным назначаются адреса относитально начала секции. Когда
создается финальный исполнямый файл, секция размещаются по некоторому адресу
`X`, и все адреса меток, назначенные в секции, увеличиваются на X, так что они
указывают на новые адреса.

Размещение каждой секции по определенному месту в памяти и коррекцию всех ссылок
на метки в секции, выполняет линкер.

Эффект размещения секций можно увидеть по тому же дампу символов, описанному выше.
Для простоы используем объектный файл однофайловой программы суммирования `sum.o`.
Для увеличения заметности искуственно разместим секцию `.text` по адресу `0x100`:

------
$ arm-none-eabi-as -o sum.o sum.s
$ arm-none-eabi-nm -n sum.o
00000000 t entry <1>
00000004 t arr
00000007 t eoa
00000008 t start
00000014 t loop
00000024 t stop
$ arm-none-eabi-ld -Ttext=0x100 -o sum.elf sum.o <2>
$ arm-none-eabi-nm -n sum.elf
00000100 t entry <3>
00000104 t arr
00000107 t eoa
00000108 t start
00000114 t loop
00000124 t stop
...
------

<1> Адреса меток назначаются с `0` от начала секции.

<2> Когда создается выполняемый файл, линкеру указано разместить секцию кода с 
адреса `0x100`.

<3> Адреса меток в `.text` переназначаются начиная с `0x100`, и все ссылки на
метки корректируются.

Процесс объединения и размещения секций в общем показаны на диаграмме:

.Объединение и размещение секций
image::relocation.png[Объединение и размещение секций]

[[lds]]
Скрипт линкера
--------------

Как было описано в предыдущем разделе, объединение и размещение секций
выполняется линкером. Программист может контролировать этот процесс через
`скрипт линкера`. Очень простой пример скрипта линкера:

.Простой скрипт линкера
------
SECTIONS { <1>
	. = 0x00000000; <2>
	.text : { <3>
		abc.o (.text); 
		def.o (.text);
	} <3>
}
------

<1> Команда `SECTIONS` наиболее важная команда, она указывает как секции
объединяются, и по каким адресам они размещаются.

<2> Внутри блока `SECTIONS` команда `.` (точка) представляет
`указатель адреса размещения`.
Указатель адреса всегда инициализируется `0x0`. Его можно модифицировать
явно присваивая новое значение. Показанная явная установка на `0x0` на самом
деле не нужна.

<3> Этот блок скрипта определяет что секция `.text` выходного файла
составляется из секций `.text` в файлах `abc.o` и `def.o`, причем именно в
этом порядке.

Скрипт линкера может быть значительно упрощен и универсализирован с помощью
использования символа шаблона `*` вместо индивидуального указания имен файлов:

.Шаблоны в скриптах линкера
------
SECTIONS {
	. = 0x00000000;
	.text : { * (.text); }
}
------

Если программа одновременно содержит секции `.text` и `.data`, объединение и 
размещение секций можно прописать вот так: 

[[linker1]]
.Несколько секций
------
include::code/sum-data.lds[]
------

Здесь секция `.text` размещается по адресу `0x0`, а секция `.data` -- `0x400`.
Отметим, что если указателю размещения не приваивать значения, секции
`.text` и `.data` будут размещены в смежных областях памяти.     

Пример скрипта линкера
~~~~~~~~~~~~~~~~~~~~~~

Для демонстрации использования скриптов линкера рассмотрим применение скрипта
<<linker1>> для размещения секций `.text` и `.data`. Для этого используем
немного измененный пример программы суммирования массива, разделив код и данные
в отдельные секции:  

[lang="armasm"]
----
include::code/sum-data.s[]
----

<1> Изменения заключаются в выделении массива в секцию `.data` и удалении 
директивы выравнивания `.align`.

<2> Также не требуется инструкция перехода на метку `start`
для обхода данных, так как линкер разместит секции отдельно. В результате
команды программы размещаются любым удобным способом, а скрипт линкера 
позаботится о правильном размещении сегментов в памяти.

При линковке программы в командной строке нужно указать использования скрипта:

------
$ arm-none-eabi-as -o sum-data.o sum-data.s
$ arm-none-eabi-ld -T sum-data.lds -o sum-data.elf sum-data.o
------

Опция `-T sum-data.lds` указывает что используется скрипт `sum-data.lds`.
Выводим таблицу символов и видим размещение сегментов в памяти: 

------
$ arm-none-eabi-nm -n sum-data.elf
00000000 t start
0000000c t loop
0000001c t stop
00000400 d arr
00000403 d eoa
------

Из таблицы символолов видно что секция `.text` размещена с адреса `0x0`,
а секция `.data` c `0x400`.

[[objdump]]
Анализ объектного/исполняемого файла утилитой `objdump`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Более подробную информацию даст утилита `objdump`:
------
$ arm-none-eabi-as -o sum-data.o sum-data.s
$ arm-none-eabi-ld -T sum-data.lds -o sum-data.elf sum-data.o
$ arm-none-eabi-objdump sum-data.elf
include::code/sum-data.objdump[]
------

<1> указание на архитектуру, 

<2> для которой предназначен исполняемый файл

<3> стартовый адрес в секции `.text`, по умолчанию `0x0` (обязателен и 
фиксирован для прошивок микроконтроллеров, т.к. на него перескакивает
аппаратный сброс)

<4> ABI -- соглашения о передаче 

<5> параметров в регистрах/стеке (для Си кода) 

<6> приведена подробная информация о секциях

<7> `.text` секция кода

<8> `.data` секция данных

<9> служебная информация

<10> столбец `Size` указывает размер секции в байтах (hex)

<11> `VMA` (Virtual Memory Address) указывает адрес размещения сегмента

<12> `Algn` (Align) автоматическое выравнивание содержимого сегмента в памяти, 
в степени двойки `2**n`: код выравнивается кратно `2**2=4` байтам,
данные не выравниваются `2**0=1` 

<13> Флаг `ALLOC` (Allocate) указывает что при загрузке программы под этот 
сегмент должна быть выделена память.

<14> `LOAD` указывает что содержимое сегмента должно загружаться из
исполняемого файла в память при использовании ОС, а для микроконтроллеров
указывает программатору что сегмент нужно прошивать.

<15> `READONLY` сегмент с константными неизменяемыми данными, которые могут быть
размещены в ROM, а при использовании ОС область памяти должна быть помечена 
в таблице системы защиты памяти как R/O. Отсутствие флага `READONLY` + наличие
`LOAD` указывает что данные должны загружаться `только в ОЗУ`. 

<16> сегмент кода

<17> сегмент данных

<18> таблица символов

<19> дизассемблированный код из секций, помеченных флагом `CODE`: `.text`

[[data-in-ram]]
Данные в RAM, пример
--------------------

Теперь мы знаем как писать скрипты линкера, и можем попытаться написать
программу, разместив данные в секции `.data` в ОЗУ.

Программа сложения модифицирована для загрузки значений из ОЗУ, и записи
результата обратно в ОЗУ: память для операндов и результат резмещена в секции
`data`. 

.Данные в ОЗУ
[lang="armasm"]
------
include::code/add-mem.s[]
------

Скрипт для линковки:

------
include::code/flash-ram.lds[]
------

Дамп таблицы символов:

------
$ arm-none-eabi-nm -n add-mem.elf
00000000 t start
0000001c t stop
a0000000 d val1
a0000001 d val2
a0000002 d result
------

Срипт линкера решил проблему с размещением данных, но 
`проблема с использованием ОЗУ еще не решена !`

RAM энергозависима (volatile) !
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ОЗУ стирается при отключении питания, поэтому для использования ОЗУ
недостаточно разместить сегменты.

NOTE: `Во флеше должнен храниться` не только код, но `и данные`, чтобы при подаче
питания специальный `startup код` выполнил `инициалиацию ОЗУ`, копируя данные из
флеша. Затем управление передается основной программе. 

Поэтому секция `.data` имеет `два адреса размещения`: адрес `хранения во флеше`
и адрес `размещения в ОЗУ`.

TIP: как видно из раздела <<objdump>>, в терминах `ld` адрес хранения (загрузки)
называется `LMA` (Load Memory Address), а адрес размещения (времени выполнения)
`VMA` (Virtual Memory Address).

Нужно сделать следующие две мсодификации, чтобы программа работала корректно:

  1. модифицировать .lds чтобы для секции `.data`
     в нем учитывались оба адреса: LMA и VMA. 

  2. написать небольшой кусочек кода, который будет `инициализировать память 
     данных`, копируя образ секции `.data` из флеша (из адреса хранения LMA) 
     в ОЗУ (по адресу исполнения, VMA).

Спецификация адреса загрузки LMA
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

VMA это адрес, который должен быть использован для вычисления адресов всех меток
при исполнении программы. В предыдущем линк-скрипте мы задали VMA секции `.data`.
LDA не указан, и по умолчанию равен VMA. Это нормально для сегментов, 
размещаемых в ROM. Но если используются инициализируемые сегменты в ОЗУ, нужно
задать отдельно VMA и LMA.  

Адрес загрузки LMA, отличающийся от адреса выполнения VMA, задается с помощью
команды `AT`. Модифицированный скрипт показан ниже:

------
SECTIONS {
	. = 0x00000000;
	.text : { * (.text); }
	etext = .; <1>

	. = 0xA0000000;
	.data : AT (etext) { * (.data); } <2>
}
------

<1> В блоках описания секций можно создавать символы, назначая им значения:
числовой адрес или текущую позицию с помощью точки ".". Символу `etext`
назначается адрес флеша, следующий сразу за концом кода.
Отметим что `etext` сам по себе не выделяет никакой
памяти, а только помечает адрес LMA сегмента .data в таблице символов.

<2> При настройке сегмента
`.data` с помощью ключевого слова `AT (etext)` назначается LMA для хранения
содержимого сегмента данных. Команде `AT` может быть передан любой адрес
или символ (значением которого является валидный адрес). Так что в результате
мы настроили адрес хранения .data на область флеша, помеченную символов `etext`. 

Копирование `.data` в ОЗУ
~~~~~~~~~~~~~~~~~~~~~~~~~

Для копирования данных инициализации из флеша в ОЗУ требуется следующая 
информация: 

  1. Адрес данных во флеше (`flash_sdata`)
  2. Адрес данных в ОЗУ (`ram_sdata`)
  3. Размер секции `.data` (`data_size`)

Имея эту информацию, сегмент `.data` может быть инициализирован
может быть скопирован следующим стартовым кодом:

------
	ldr   r0, =flash_sdata
	ldr   r1, =ram_sdata
	ldr   r2, =data_size
copy:	
	ldrb  r4, [r0], #1
	strb  r4, [r1], #1
	subs  r2, r2, #1
	bne   copy
------

Для получения такой информации скрипт линкера нужно немного модифицировать:

[[linker2]]
.Скрипт линкера с символами для копирования секции `.data`
------
SECTIONS {
	. = 0x00000000;
	.text : { * (.text); }
	flash_sdata = .; <1>

	. = 0xA0000000;
	ram_sdata = .; <2>
	.data : AT (flash_sdata) { * (.data); }
	ram_edata = .; <3>
	data_size = ram_edata - ram_sdata; <3>
}
------

<1> Начало данных во флеше сразу за секцией кода.

<2> Начало данных -- базовый адрес ОЗУ в адресном пространстве процессора.

<3> Получение размера непросто: размер вычисляется вычитанием адресов
метод начала и конца данных. Да, простые выражения тоже можно использовать в
скрипте линкера.

Полный листинг программы с добавленной инициализацией данных:

.Инициализация ОЗУ
[lang="armasm"]
------
include::code/add-ram.s[]
------

.add-ram.objdump
------
include::code/add-ram.objdump[]
------

Программа была ассемблирована и слинкована используя .lds в <<linker2>>.

Запуск и тестирование программы в Qemu:

------
qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
(qemu) xp /4dw 0xA0000000
a0000000:         10         30         40          0
------

NOTE: На реальной физической системе с SDRAM, память не может использована 
сразу. Сначала нужно инициализировать контроллер памяти, и только затем
обращаться к ОЗУ. Наш код работает потому, что симулятор не требует
инициализации контроллера.

[[exc-handle]]
Обработка аппаратных исключений
-------------------------------

Все примеры программ, приведенные выше, содержат гигантский баг: `первые
8 машинных слов в адресном пространстве зарезервированы для векторов
исключений`. Когда возникает исключение, выполняется аппаратный переход
на один из этих жестко заданных меток. Исключения и их адреса приведены
в следующей таблице:

.Адреса векторов исключений
[options="header"]
|======
| Исключение               || Адрес
| Сброс | Reset                   | 0x00
| Неопределенная инструкция | Undefined Instruction	  | 0x04
| Программное прерывание (SWI) | Software Interrupt (SWI)| 0x08
| Ошибка предвыборки | Prefetch Abort	  | 0x0C
| Ошибка данных | Data Abort		  | 0x10
| Резерв, не используется | Reserved, not used	  | 0x14
| Аппаратное прерывание | IRQ			  | 0x18
| Быстрое прерывание | FIQ			  | 0x1C
|======

Предполагается что по этим адресам находятся команды перехода, которые
передадут управление на соответствующий произвольный адрес обработчика
исключения. Во всех примерах ранее бы не вставляли таблицу обработчиков
исключений, так как мы предполагали что эти исключения не случатся. Все
эти программы можно скорректировать, слинковав их со следующим кодом:  

------
	.section "vectors"
reset:	b     start
undef:  b     undef
swi:	b     swi
pabt:	b     pabt
dabt:	b     dabt
	nop
irq:	b     irq
fiq:	b     fiq
------

Только обработчик reset векторизован на отдельный адрес `start`. Все остальные
исключения векторизованы сами на себя. Таким образом если случится любое
исключение, процессор зациклится на соответствущем векторе. В этом случае
возникшее исключение может быть идентифицирвовано в отладчике (мониторе Qemu,
в нашем случае) по адресу указателя команд `pc=r15`.

В ассемблерном коде видно применение директивы `.section` которая позволяет
создавать секции с произвольными именами, чтобы прописать для них отдельную
обработку в скрипте линкера.  

Чтобы обеспечить правильное размещение таблицы обработчиков, нужно
скорректировать скрипт линкера: 

------
SECTIONS {
	. = 0x00000000;
	.text : {
		* (vectors);
		* (.text); 
		...
	}
	...
}
------

Обратите внимание что секция `vectors` размещена сразу за инициализацией
указателя размещения на первом месте, до всего остального кода, что гарантирует
что таблица векторов будет находится по жесткому адресу `0x0`.

[[c-startup]]
Стартап-код на Си
-----------------

Если процесс только что был сброшен, невозможно напрямую выполниь Си код,
так как в отличие от ассемблера, программы на Си требуют для себя некоторой
предварительной настройки. В этом разделе описаны эти предварительные требования,
и как их выполнить.

Мы возьмем пример Си-программы которая вычисляет сумму массива. И к концу
раздела мы уже будем способны, сделав некоторые низкоуровневые
настройки, передать управление и выполнить ее.

[[csum]]
.Сумма массива на Си
[lang="c"]
------
include::code/csum.c[]
------

Перед передачей управления Си-коду, нужно выполнить следующие настройки:

  1. Стек
  2. Глобальные переменные
     a. Инициализированные
     b. Неинициализированные
  3. Константные данные

Стек
~~~~

C uses the stack for storing local (auto) variables, passing function
arguments, storing return address, etc. So it is essential that the
stack be setup correctly, before transferring control to C code.

Stacks are highly flexible in the ARM architecture, since the
implementation is completely left to the software. For people not
familiar with the ARM architecture a overview is provided in
<<arm-stacks>>.

To make sure that code generated by different compilers is
interroperable, ARM has created the
http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042a/IHI0042A_aapcs.pdf[ARM
Architecture Procedure Call Standard (AAPCS)]. The register to be used
as the stack pointer and the direction in which the stack grows is all
dictated by the AAPCS. According to the AAPCS, *register `r13`* is to
be used as the stack pointer. Also the stack should be
*full-descending*.

One way of placing global variables and the stack is shown in the
following diagram.

.Stack Placement
image::stack.png[]

So all that has to be done in the startup code is to point `r13` at
the highest RAM address, so that the stack can grow downwards (towards
lower addresses). For the `connex` board this can be acheived using
the following ARM instruction.

------
	ldr sp, =0xA4000000
------

Note that the the assembler provides an alias `sp` for the `r13`
register.

NOTE: The address `0xA4000000` itself does not correspond to RAM. The
RAM ends at `0xA3FFFFFF`. But that is OK, since the stack is
*full*-descending, during the first push the stack pointer will be
decremented first and the value will be stored.

Global Variables
~~~~~~~~~~~~~~~~

When C code is compiled, the compiler places initialized global
variables in the `.data` section. So just as with the assembly, the
`.data` has to be copied from Flash to RAM.

The C language guarantees that all uninitialized global variables will
be initialized to zero. When C programs are compiled, a separate
section called `.bss` is used for uninitialized variables. Since the
value of these variables are all zeroes to start with, they do not
have to be stored in Flash. Before transferring control to C code, the
memory locations corresponding to these variables have to be
initialized to zero.

Read-only Data
~~~~~~~~~~~~~~

GCC places global variables marked as `const` in a separate section,
called `.rodata`. The `.rodata` is also used for storing string
constants. 

Since contents of `.rodata` section will not be modified, they can be
placed in Flash. The linker script has to modified to accomodate
this. 

Startup Code
~~~~~~~~~~~~

Now that we know the pre-requisites we can create the linker script
and the startup code. The linker script <<linker2>> is modified to
accomodate the following.

  1. `.bss` section placement 
  2. `vectors` section placement
  3. `.rodata` section placement

The `.bss` is placed right after `.data` section in RAM. Symbols to
locate the start of `.bss` and end of `.bss` are also created in the
linker script. The `.rodata` is placed right after `.text` section in
Flash. The following diagram shows the placement of the various
sections.

.Section Placement
image::csections.png[]

.Linker Script for C code
------
include::code/csum.lds[]
------

The startup code has the following parts

    1. exception vectors
    2. code to copy the `.data` from Flash to RAM
    3. code to zero out the `.bss`
    4. code to setup the stack pointer
    5. branch to main

.C Startup Assembly
[lang="armasm"]
------
include::code/startup.s[]
------

To compile the code, it is not necessary to invoke the assembler,
compiler and linker individually. `gcc` is intelligent enough to do
that for us. 

As promised before, we will compile and execute the C code shown
in <<csum>>.

------
$ arm-none-eabi-gcc -nostdlib -o csum.elf -T csum.lds csum.c startup.s
------

The `-nostdlib` option is used to specify that the standard C library
should not be linked in. A little extra care has to be taken when the
C library is linked in. This is discussed in <<c-library>>.

A dump of the symbol table will give a better picture of how things
have been placed in memory.

------
$ arm-none-eabi-nm -n csum.elf
00000000 t reset	<1>
00000004 A bss_size
00000004 t undef
00000008 t swi
0000000c t pabt
00000010 t dabt
00000018 A data_size
00000018 t irq
0000001c t fiq
00000020 T main
00000090 t start	<2>
000000a0 t copy
000000b0 t init_bss
000000c4 t zero
000000d0 t init_stack
000000d8 t stop
000000f4 r n		<3>
000000f8 A flash_sdata
a0000000 d arr		<4>
a0000000 A ram_sdata
a0000018 A ram_edata
a0000018 A sbss
a0000018 b sum		<5>
a000001c A ebss
------
<1> `reset` and the rest of the exception vectors are placed starting from `0x0`.

<2> The assembly code is placed right after the 8 exception vectors
    (`8 * 4 = 32 = 0x20`).

<3> The read-only data `n`, is placed in Flash after the code.

<4> The initialized data `arr`, an array of 6 integers, is placed at
    the start of RAM `0xA0000000`.

<5> The uninitialized data `sum` is placed after the array of 6
    integers. (`6 * 4 = 24 = 0x18`)

To execute the program, convert the program to `.bin` format, execute
in Qemu, and dump the `sum` variable located at `0xA0000018`.

------
$ arm-none-eabi-objcopy -O binary csum.elf csum.bin
$ dd if=csum.bin of=flash.bin bs=4096 conv=notrunc
$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
(qemu) xp /6dw 0xa0000000
a0000000:          1         10          4          5
a0000010:          6          7
(qemu) xp /1dw 0xa0000018
a0000018:         33
------

[[c-library]]
Using the C Library
-------------------

FIXME: This section is yet to be written.

[[inline-assembly]]
Inline Assembly
---------------

FIXME: This section is yet to be written.

[[make]]
Using `make` for build automation
---------------------------------

If you bothered with set of long commands you enter every time compiling
samples in this tutorial, that's time to use `make` tool. 
`make` is utility which controls file dependencies, described in `Makefile`.

Writing makefiles is `must have` skill for programmer, especially for large
multifile projects contains dozens of files, which must be  
assembled, compiled and translated into lot of different formats.

Every dependency between two or more files must be configured into `rule`:

------
<target> : <source>
<tab><compiling command1>
<tab><compiling command2>
...
------

`target`:: is one file name, or few file names, delimited by spaces. 
This file(s) will be created or updated by this make rule.

`source`:: null or more file names delimited by spaces. This file(s) will be
`checked for modifications` by last edit time marker.

`tab`:: is tabulation char with ascii code 0x09, you must have editor able to
work with tabs not overwriting them into sequences of spaces. Make rule can
have zero rules or some tabbed compiling commands.

`compiling command`:: any command, like assembly or linker call, which updates
`target`s, doing some useful job.   

NOTE: The main principle of every makefile rule: if one of `source` files 
`newer` then one of `target` file, rule body will be executed to update
`target` s.

Let's write simple makefile for tiny program, described in `Hello ARM` section:

.Makefile
------
emulation: add.flash
	qemu-system-arm -M connex -pflash add.flash \
		-nographic -serial /dev/null
flash.bin: add.bin
	dd if=/dev/zero of=flash.bin bs=4K count=4K
	dd if=add.bin of=flash.bin bs=4K conv=notrunc
add.bin: add.elf
	arm-none-eabi-objcopy -O binary add.elf add.bin
add.elf: add.o	
	arm-none-eabi-ld -o add.elf add.o
add.o: add.s
	arm-none-eabi-as -o add.o add.s
------
* note backslash and next left-tabbed line if first rule: 
you can split long command into set
of lines; each line must be tabbed with one or more tab to follow makerule 
syntax. 

Enter make command without any arguments in directory with Makefile and source
files, and you will get automatically compiled binary files and running Qemu.

------
$ make
...
QEMU 2.1.2 monitor - type 'help' for more information
(qemu)
------

NOTE: If you use make without parameters, `first rule` in Makefile will be
processed as main `target`, walking over dependencies in all rules.

[[makeseltarget]]
Selecting specific `target`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you need to update only specific `target`, not first rule, put required 
file name after make command:

------
$ make add.o
make: 'add.o' is up to date.
------

This command will build only add.o object file, if and only if you modified add.s 
before command run. If you see some message like `make: 'add.o' is up to date.`,
source file was not changed, and make will not run assembler rule. 

This is very useful if you have lot of source files (thousands of files, like 
Linux kernel for example), and fix some bug only in one source file. Without
make (using simple .rc shell script of .bat ch file) every tiny change in 
source file
will tend recompiling of all project, which can lasts for several hours.
Using `make` you can do only few required compiler and linker calls, which will
be much much faster.

Returning to our add.o, you can force assembler run not changing add.s source
file, by `touch`ing them:

------
$ touch add.s 
$ make add.o
arm-none-eabi-as -o add.o add.s
------

`touch` command changes only modification time of source file add.s, not
changing it's content, thus `make` will note that file changed, and run
assembler for selected target=add.o.

By default, make will print every command and its output. If you have some
reason to quiet make logging, you can prefix some compiler commands in make rule
with "-" minus sign.  

[[makevars]]
Variables
~~~~~~~~~

Variable is object in makefile, which can contain some text. For example, we
can define some vars in makefile, and use them in all rules.

Very useful make tip: you can use two special variables: $@ and @<.

`$@`:: variable represents left side of Makefile rule, typically single 
`target` file name

`$<`:: variable will be replaced by `first` file if `source` list

NOTE: running make, you can forced redefine any variables values: change
compiler options, tune rules, and ever use one universal makefile for all
of your projects.  

So, we can change our makefile to be more adaptive:

------
# APPlication name, you can change it in make command line parameters
# to compile another onefile program with same makefile
APP = add

# some std.variables widely used in Linux source builds:
## architecture
ARCH = arm
## target system triplet
TARGET = $(ARCH)-none-eabi-
## std. toolchain commands
AS = $(TARGET)as
LD = $(TARGET)ld
CC = $(TARGET)gcc
CXX = $(TARGET)g++
OBJDUMP = $(TARGET)objdump
OBJCOPY = $(TARGET)objcopy

# FlashROM size of target system, in 4K block
FLASHBLOCKS = 4K
emu: $(APP).flash
	qemu-system-$(ARCH) -M connex -pflash $< \
		-nographic -serial /dev/null

$(APP).flash: $(APP).bin
	dd if=/dev/zero of=$@ bs=4K count=$(FLASHBLOCKS)
	dd if=$< of=$@ bs=4K conv=notrunc
$(APP).bin: $(APP).elf
	$(OBJCOPY) -O binary $< $@
$(APP).elf: $(APP).o	
	$(LD) -o $@ $<
$(APP).o: $(APP).s
	$(AS) -o $@ $<
------

First of all, we replaced all file names with $(APP).<extension>.

NOTE: Note use of variables in `$(...)` brackets, and specials `$@` and `$<`

Then, we replaced all file parameters in assembler/linker calls with 
`$@` and `$<`, which makes our rules more rigid.

Also we used some std.variables to select target system architecture, and
prefixed all toolchain calls with $(TARGET) variable.

NOTE: Now we can compile `another` source file: arrsum.s, contains listing 
of array summation program. We `override APP variable value in command line`:  

------
$ make APP=arrsum

arm-none-eabi-as -o arrsum.o arrsum.s
arm-none-eabi-ld -o arrsum.elf arrsum.o
arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 0000000000008000
arm-none-eabi-objcopy -O binary arrsum.elf arrsum.bin
dd if=/dev/zero of=arrsum.flash bs=4K count=4K
4096+0 records in
4096+0 records out
16777216 bytes (17 MB) copied, 0.0184385 s, 910 MB/s
dd if=arrsum.bin of=arrsum.flash bs=4K conv=notrunc
0+1 records in
0+1 records out
48 bytes (48 B) copied, 5.9686e-05 s, 804 kB/s
qemu-system-arm -M connex -pflash arrsum.flash \
        -nographic -serial /dev/null
QEMU 2.1.2 monitor - type 'help' for more information
(qemu) q
------

Wow, we compiled another program without any change in Makefile, all file names
was renamed automatically, we jet get separate flash image and running Qemu 
in one command.

Let's dig into details 

[[makestdvars]]
Standard make variables
~~~~~~~~~~~~~~~~~~~~~~~

Some vars widely used in makefiles of OpenSource program source packages.
You can use this makefiles as samples for lot of make tricks, 
not covered by this tutorial.

`ARCH`:: target system architecture: arm, mips, i386, x86_64, avr,...

`TARGET`:: target system `triplet`: arm-none-eabi, i486-none-elf, 
i686-linux-uclibc, selects lot of cross-compiler config parameters, vastly
impacts on compiled binary code: CPU command set, memory layout,...

`BUILD`:: triplet for your developer computer, something like x86_64-linux-gnu. 
This var can be used if you build some helper programs, which must run on your
workstation, for example to autogenerate some code for TARGET.

`AS`:: assembler program name, as be `as` for host system, and something like 
`super-puper-elf-as` for crosscompiler toolchain

`LD`:: linker

`CC`:: pure C compiler

`CXX`:: C++ compiler

`NM`::

`OBJDUMP`::

`OBJCOPY`:: object file tools

`ASFLAGS`:: assembler flags

`LDFLAGS`:: linker flags

`CFLAGS`:: flags for C compiler, including optimization `OPT` variable 

`CXXFLAGS`:: flags for C++ compiler 

[[makestdtargets]]
Standard targets
~~~~~~~~~~~~~~~~

OpenSource developers world have some widely used standard targets:

`all`:: build all project, `it must be first rule in Makefile`

`doc`:: build documentation, using some of asciidoc, DocBook, LaTeX,.. markup
translators, which will translate doc sources into some widely used document
format like .html and manual.pdf files. Fortunately, you can use special program
packages (for some programming languages like Java, C++,..) which let you
process your program sources and autogenerate tables of labels, function 
definitions with parameters a.k.a call signatures, source file lists, 
and include this tables into documentation.   

`clean`:: remove all intermediate files (.o .elf .bin ...) and program binary.
Typical use of `clean` is command which you must use for total program rebuild
from scratch:

------
make clean
make
------

`distclean`:: same as clean with removing generated files going into binary
distribution of built program package: .pdf/.html documentation,..

.Recommended Makefile rules
------
FLASH = add.flash arrsum.flash strlen.flash 

.PHONY: all
all: $(FLASH)

.PHONY: clean
	rm -rf *.o *.elf *.bin *.flash
	
.PHONY: distclean
distclean: clean
	rm -rf doc/manual.pdf
------

[[makephony]]
.PHONY targets
~~~~~~~~~~~~~

In previous makefile sample, you can see `.PHONY some` directives.
This directives marks `target` is one that is not really the name of a file;
rather it is just `a name for a recipe` to be executed when you make an 
explicit request `make some` command.

If you write a rule whose `recipe goal will not create the target file`,
mark it with .PHONY, and the recipe will be executed every time the target 
comes up for remaking. Here is an example is `all` and `clean` targets.

Because the rm command in `clean` rule does not create a file named "clean", 
probably no such file will ever exist. Therefore, the rm command will be 
executed every time you say ‘make clean’.

NOTE: You can think about set of phony targets in Makefile as something
like `command line menu`: you select required action by run `make action`

[[makeqemu]]
Run qemu from `Makefile`
~~~~~~~~~~~~~~~~~~~~~~~~

If you define special `emu` rule:
------
.PHONY: emu
emu: $(APP).flash
	qemu-system-$(ARCH) -M connex -pflash $< \
		-nographic -serial /dev/null
------

[[makefiles]]
Some file/directory hints
~~~~~~~~~~~~~~~~~~~~~~~~~

You can get APP name using hint:

------
APP = $(notdir $(CURDIR))
------

`$(CURDIR)`:: gives you current directory, where you run make

`$(notdir ...)`:: internal functions removes leading /home/user/... part of
directory name

Thus you automagically set APP name to current directory name, for example
you made new project:

------
$ cd ~
$ mkdir superjob && cd superjob
$ git init
... write some code ...
$ make -f ~/universal.makefile
------

NOTE: `-f` make option let you set file other then ./Makefile, you can use
only one ~/universal.makefile for all of your projects.

[[makerules]]
Using pattern rules
~~~~~~~~~~~~~~~~~~~

Finally, let's do some strange thing: define universal pattern rules, which will 
assemble, compile and link `any` file with specific extensions. 

.Makefile pattern rules
------
%.o: %.s
	$(AS) $(ASFLAGS) -o $@ $<
%.o: %.c
	$(CC) $(CCFLAGS) -o $@ $<
%.o: %.cpp
	$(CXX) $(CXXFLAGS) -o $@ $<
%.elf: %.o	
	$(LD) $(LDFLAGS) -o $@ $<
%.bin: %.elf
	$(OBJCOPY) -O binary $< $@
%.flash: %.bin
	dd if=/dev/zero of=$@ bs=4K count=$(FLASHBLOCKS)
	dd if=$< of=$@ bs=4K conv=notrunc
------

Now you don't need to define rules for every file compiling like:

------
file1.o : file1.s
	$(AS) -o $@ $<
file2.o : file2.s
	$(AS) -o $@ $<
#### another +100500 dumb rules ####
file333.o : file333.s
	$(AS) -o $@ $<
------

Just define one rule:

------
.PHONY: all
all: file1.flash file2.flash ... file10050.flash
------

and pattern rules set will be automagically build your huge project.

Suddenly, make has some metarules compiled in, and you can compile assembly,
C/C++ and some other filetype pairs without any metarule in you file. 

[[contributing]]
Contributing
------------

Like every other open source project, we gladly accept
contributions. Sections that need help have been marked with
FIXMEs. All contributions will be duly credited in the credits page.

This document's source is maintained in a public git repo located at
https://github.com/bravegnu/gnu-eprog To contribute to the project,
fork the project on github and send in a pull request.

The document is written in
http://www.methods.co.nz/asciidoc/[asciidoc], and converted to HTML
using the http://docbook.sourceforge.net/[docbook-xsl] stylesheets.

Required software install
~~~~~~~~~~~~~~~~~~~~~~~~~

------
sudo apt install asciidoc docbook imgsizer dia
sudo apt install libsaxon-java libxslthl-java
------

[[credits]]
Credits
-------

People
~~~~~~

  * The original tutorial was written by Vijay Kumar B.,
    <vijaykumar@bravegnu.org>

  * Jim Huang, Jesus Vicenti, Goodwealth Chu, Jeffrey Antony,
    Jonathan Grant, David LeBlanc, reported typos and suggested
    fixes in the code and text.

  * Dmitry Ponyatov added some info on build automation using make tool.
	
Tools
~~~~~

The following great free software tools were used for the construction
of the tutorial.

  1. http://www.methods.co.nz/asciidoc/[asciidoc] for lightweight markup
  2. http://www.xmlsoft.org/XSLT/xsltproc2.html[xsltproc] for HTML transformation
  3. http://docbook.sourceforge.net/[docbook-xsl] for the stylesheets
  4. http://softwaremaniacs.org/soft/highlight/en/[highlight.js] for syntax highlighting
  5. http://www.gnome.org/projects/dia/[dia] for diagram creation
  6. http://www.gosquared.com/liquidicity/archives/611[GoSquared Arrow
     Icons] for the navigation icons
  7. http://www.selenic.com/mercurial/[mercurial] for version control
  8. http://www.gnu.org/software/emacs/[emacs] ...

[[copyright]]
Tutorial Copyright
------------------
"Embedded Programming with the GNU Toolchain" is Copyright (C) 2009,
2010, 2011 Vijay Kumar B. <vijaykumar@bravegnu.org>

This work is licensed under a
http://creativecommons.org/licenses/by-sa/3.0/[Creative Commons
Attribution-Share Alike 3.0 Unported License].

[[arm-prog-model]]
Appendix A: ARM Programmer's Model
----------------------------------

A simplified ARM programmer's model is provided in this section.

.Register File

In the ARM processor, 16 general purpose registers are available at
any time. Each register is 32-bit in size. The registers are referred
to as `rn`, where n represents the register index. All instructions
treat registers `r0` to `r13` equally. Any operation that can be
performed on `r0` can be performed equally well on registers `r1` to
`r13`. But `r14` and `r15` are assigned special functions by the
processor. `r15` is the program counter, and contains the address of
the next instruction to be fetched. `r14` is the link register, and
used to store the return address, when a subroutine is invoked.

TIP: Though register `r13` has no special function assigned to by the
processor, conventionally operating systems use it as the stack
pointer, and thus points to the top of the stack.

.Current Program Status Register

The Current Program Status Register (`cpsr`) is a dedicated 32-bit
register, that contains the following fields.

    . Condition Flags
    . Interrupt Masks
    . Processor Mode
    . Processor State

Only the condition flags field will be used in the examples provided
in this tutorial. And hence only the condition flags will be
elaborated here.

The condition flags indicates the various conditions that occur while
performing arithmetic and logical operations. The various condition
flags and their meaning are given in the following table.

.Condition Flags
[options="header"]
|======
| Flag         | Meaning
| Carry `C`    | Operation caused a carry.
| Overflow `O` | Operation caused an overflow.
| Zero `Z`     | Operation resulted in 0.
| Negative `N` | Operation resulted in a negative value.
|======

[[arm-iset]]
Appendix B: ARM Instruction Set
-------------------------------

The ARM processor has a powerful instruction set. But only a subset
required to understand the examples in this tutorial will be discussed
here.

The ARM has a load store architecture, meaning that all arithmetic and
logical instructions take only register operands. They cannot directly
operate on operands to memory. Separate instruction load and store
instructions are used for moving data between registers and memory.

In this section, the following class of instructions will be
elaborated

  1. Data Processing Instructions
  2. Branch Instructions
  3. Load Store Instructions

.Data Processing Instructions

The most common data processing instructions are listed in the
following table.

.Data Processing Instructions
[options="header"]
|======
| Instruction     | Operation     | Example		
| `mov rd, n`     | `rd = n`      | `mov r7, r5`     `; r7 = r5`
| `add rd, rn, n` | `rd = rn + n` | `add r0, r0, #1` `; r0 = r0 + 1`
| `sub rd, rn, n` | `rd = rn - n` | `sub r0, r2, r1` `; r0 = r2 + r1`
| `cmp rn, n`     | `rn - n`      | `cmp r1, r2`     `; r1 - r2`
|======

By default data processing instructions *do not* update the condition
flags. Instructions will update condition flags if it is suffixed with
an `S`. For example, the following instruction adds two registers and
updates the condition flags.

------
adds r0, r1, r2
------

One exception to this rule is the `cmp` instruction. Since the only
purpose of the `cmp` instruction is to set condition flags, it does
not require the `s` suffix, for setting flags.

.Branch Instructions

The branch instructions cause the processor to execute instructions
from a different address. Two branch instruction are available - `b`
and `bl`. The `bl` instruction in addition to branching, also stores
the return address in the `lr` register, and hence can be used for
sub-routine invocation. The instruction syntax is given below.

------
b label        ; pc = label
bl label       ; pc = label, lr = addr of next instruction
------

To return from the subroutine, the `mov` instruction can be used as
shown below.

------
mov pc, lr
------

.Conditional Execution

Most other instruction sets allow conditional execution of branch
instructions, based on the state of the condition flags. In ARM,
almost all instructions have can be conditionally executed.

If corresponding condition is true, the instruction is executed. If
the condition is false, the instruction is turned into a `nop`. The
condition is specified by suffixing the instruction with a condition
code mnemonic.

[options="header"]
|======
| Mnemonic       | Condition
| EQ		 | Equal
| NE		 | Not Equal
| CS		 | Carry Set
| CC		 | Carry Clear
| VC		 | Overflow Clear
| VS		 | Overflow Set
| PL		 | Positive
| MI		 | Minus
| HI		 | Higher Than
| HS		 | Higher or Same
| LO		 | Lower Than
| LS		 | Lower or Same
| GT		 | Greater Than
| GE		 | Greater Than or Equal
| LT		 | Less Than
| LE		 | Less Than or Equal
|======

In the following example, the instruction moves `r1` to `r0` only if
carry is set.

------
MOVCS r0, r1
------

.Load Store Instructions

The load store instruction can be used to move single data item
between register and memory. The instruction syntax is given below.

------
ldr   rd, addressing    ; rd = mem32[addr]
str   rd, addressing    ; mem32[addr] = rd
ldrb  rd, addressing    ; rd = mem8[addr]
strb  rd, addressing    ; mem8[addr] = rd
------

The `addressing` is formed from two parts

  * base register
  * offset

The base register can be any general purpose register. The offset and
base register can interact in 3 different ways.

Offset::
The offset is added or subtracted from the base register to form the
address. `ldr` Syntax: `ldr rd, [rm, offset]`

Pre-indexed::
The offset is added or subtracted from the base register to form the
address, and the address is written back to the base register. `ldr`
Syntax `ldr rd, [rm, offset]!`

Post-indexed::
The base register contains the address to be accessed, and the offset
is added or subtracted from the address and stored in the base
register. `ldr` Syntax `ldr rd, [rm], offset`

The offset can be in the following formats

Immediate:: 
Offset is an unsigned number, that can be added or subtracted from the
base register. Useful for accessing structure members, local variables
in the stack. Immediate values start with a `#`.

Register::
Offset is an unsigned value in a general purpose register, that can be a
added or subtracted from the base register. Useful for accessing array
elements.

Some examples of load store instructions are given below.

------
ldr  r1, [r0]              ; same as ldr r1, [r0, #0], r1 = mem32[r0]
ldr  r8, [r3, #4]          ; r8 = mem32[r3 + 4]
ldr  r12, [r13, #-4]       ; r12 = mem32[r13 - 4]
strb r10, [r7, -r4]        ; mem8[r7 - r4] = r10
strb r7, [r6, #-1]!        ; mem8[r6 - 1] = r7, r6 = r6 - 1
str  r2, [r5], #8          ; mem32[r5] = r2, r5 = r5 + 8
------

[[arm-stacks]]
Appendix C: ARM Stacks
----------------------

Stacks are highly flexible in the ARM architecture, since the
implementation is completely left to the software.

.Stack Instructions

The ARM instruction set does not contain any stack specific
instructions like `push` and `pop`. The instruction set also does not
enforce in anyway the use of a stack. Push and pop operations are
performed by memory access instructions, with auto-increment
addressing modes.

.Stack Pointer

The stack pointer is a register that points to the top of the
stack. In the ARM processor, there are no dedicated stack pointer
registers, and any one of the general purpose registers can be used as
the stack pointer.

.Stack Types

Since it is left to the software to implement a stack, different
implemenation choices result different types of stacks. There are two
types of stack depending on how the stack grows.

Ascending stack:: In a push the stack pointer is incremented, i.e the
stack grows towards higher address.

Descending stack:: In a push the stack pointer is decremented, i.e the
stack grows towards lower address.

There are two types of stack depending on what the stack pointer
points to.

Empty stack:: Stack pointer points to the location in which the next
item will be stored. A push will store the value, and increment the
stack pointer. 

Full stack:: Stack pointer points to the location in which the last
item was stored. A push will increment the stack pointer and store the
value.

Four different stacks are possible - full-ascending, full-descending,
empty-ascending, empty-descending. All 4 can be implemented using the
register load store instructions.

